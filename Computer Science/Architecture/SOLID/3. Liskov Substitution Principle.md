The third SOLID principle is the Liskov Substitution Principle (LSP), named after Barbara Liskov.

# Definition

> [!info]
> The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.

In other words, subclasses must be substitutable for their base classes without causing unexpected behavior.

# Example: Rectangle and Square

Suppose you define a `Rectangle` class:

```cpp
class Rectangle {
protected:
    int width, height;
public:
    Rectangle(int width, int height) : width(width), height(height) {}

    int get_width() const { return width; }
    int get_height() const { return height; }
    virtual void set_width(int w) { width = w; }
    virtual void set_height(int h) { height = h; }
    int area() const { return width * height; }
};
```

And now imagine you’re using an API that processes rectangles defined elsewhere:

```cpp
void process(Rectangle& r) {
    int width = r.get_width();
    r.set_height(10);
    std::cout << "Expected area = " << (width * 10) 
              << ", got area = " << r.area() << std::endl;
}
```

## Usage

```cpp
Rectangle r {3, 4};
process(r); // Output: Expected area = 30, got area = 30
```

As long as you’re just working with rectangles, everything works as expected.

## Inheriting Square from Rectangle

You might try to model a `Square` by inheriting from `Rectangle`:

```cpp
class Square : public Rectangle {
public:
    Square(int size) : Rectangle(size, size) {}

    void set_width(int w) override {
        width = height = w;
    }
    void set_height(int h) override {
        width = height = h;
    }
};
```

## Violation Example

Now, try substituting a `Square` into the `process` function:

```cpp
Square s{5};
process(s); // Output: Expected area = 50, got area = 100
```

- `process` gets the width (5), then sets the height to 10.
- In `Square`, setting the height to 10 also sets the width to 10.
- The actual area becomes 10 × 10 = 100, not the expected 50.

This breaks the ==Liskov Substitution Principle==, because `Square` does not behave as an ordinary `Rectangle`.

> [!warning]
> Inheriting `Square` from `Rectangle` allows assignment but alters behavior in unexpected ways, breaking substitutability.

# How to Fix This

- Do not force an is-a relationship where behaviors diverge.
- Instead of making `Square` inherit from `Rectangle`, consider alternatives:
	- Use composition.
	- Use a factory to create rectangles and squares as needed.
	- Possibly, have a flag for square-ness in a single class, if appropriate for your domain.

# A better example:

```cpp
struct RectangleFactory {
    static Rectangle create_rectangle(int width, int height) {
        return Rectangle(width, height);
    }
    static Rectangle create_square(int size) {
        return Rectangle(size, size);
    }
};
```

This avoids inheritance-based surprises and ensures substitutability.

# Summary

- The Liskov Substitution Principle ensures that derived classes can stand in for base classes without altering program correctness.
- Violating LSP, as with the classic `Rectangle` and `Square` example, leads to bugs and unexpected behavior.
- Model hierarchies carefully; question is-a relationships and prefer designs that maintain behavioral consistency.

# Language specific

## C++

### Virtual functions

Using virtual functions—the core mechanism behind polymorphism in object-oriented languages like C++—can be very powerful for achieving flexible behavior. 

However, when it comes to the Liskov Substitution Principle (LSP), simply introducing virtual functions does not solve the fundamental design issue highlighted in the [[3. Liskov Substitution Principle#Example Rectangle and Square|Rectangle/Square example]].

> [!warning]
> Virtual functions allow derived classes to modify or extend base class behavior.
However, LSP requires that substituting a derived class never breaks the expectations set by the base class’s interface and documented behavior.

### Virtual Functions: Not a Panacea for LSP

- In the Rectangle/Square example, making `set_width` and `set_height` virtual allows Square to override their behavior.
- Nevertheless, the problem remains:
- `Square::set_width()` and `Square::set_height()` change both dimensions, which violates the expected behavior of `Rectangle` setters (that only change one dimension).
- Any client code written against `Rectangle` expects independent width and height, and substituting a `Square` causes unexpected results or subtle bugs.

### Why Factories or Composition Might Be Better

-  Factories:
	- Decouple construction logic and allow you to create squares and rectangles as 
appropriate, without enforcing a problematic inheritance relationship.
- Composition:
	- You can share code by extracting common behaviors and state into reusable components, avoiding the “is-a” trap.
	- These approaches ensure you cannot mistakenly substitute a class with fundamentally different behavior, thus adhering to LSP.

> [!warning]
> Virtual functions do not “fix” a misuse of inheritance where the subclass breaks the contract—the promises made by the base class methods’ documentation and expected side effects.
