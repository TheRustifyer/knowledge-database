The second principle from the SOLID design principles we’re going to discuss is the Open-Closed Principle (OCP).

> [!info]
> The Open-Closed Principle states that software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.

This means you should be able to add new functionality without changing existing code.
## Example: Filtering Products on a Website

Suppose you’re building a website that sells products. Each product has traits like color and size, defined as enums:

	•	Color: `red`, `green`, `blue`
	•	Size: `small`, `medium`, `large`

A `Product` class might have:

	•	`name`
	•	`color`
	•	`size`

### Initial Simple Filter Implementation

You may start by implementing a filter that can filter products by color:

```cpp
std::vector<Product*> by_color(const std::vector<Product*>& items, Color color) {
    std::vector<Product*> result;
    for (auto& item : items) {
        if (item->color == color)
            result.push_back(item);
    }
    return result;
}
```

Usage:

```cpp
Product apple{"Apple", Color::green, Size::small};
Product tree{"Tree", Color::green, Size::large};
Product house{"House", Color::blue, Size::large};
std::vector<Product*> items{&apple, &tree, &house};

auto green_items = by_color(items, Color::green);
for (auto item : green_items)
    std::cout << item->name << " is green\n";
```

This works fine as long as the only filtering needed is by color.

# Problem: Extending Filtering Criteria

What if your manager asks you to also filter by size? You might copy the filter function and create one for size:

```cpp
std::vector<Product*> by_size(const std::vector<Product*>& items, Size size) {
    // Similar code filtering by size
}
```

When the manager later asks to filter by both size and color, you create yet another function `by_size_and_color`.

Now, with each additional criterion or combination, the number of filtering functions grows exponentially.

##  Why This Violates Open-Closed Principle

•	You modify existing filter interfaces and functions to add new capabilities.
•	This breaks binary compatibility and requires retesting already shipped code.
•	The code is harder to maintain and extend.

This approach has poor scalability.

# Solution: Specification Pattern with Open-Closed Principle

To respect the ==Open-Closed Principle==, you can use the ==Specification Pattern==:

## Key Interfaces

Define two template interfaces:

```cpp
template <typename T>
struct Specification {
    virtual bool is_satisfied(T* item) const = 0;
};

template <typename T>
struct Filter {
    virtual std::vector<T*> filter(const std::vector<T*>& items,
                                   const Specification<T>& spec) const = 0;
};
```

These are open to extension (through inheritance) but do not need to be modified.

## Implementing a Better Filter

Implement a concrete filter:

```cpp
struct BetterFilter : Filter<Product> {
    std::vector<Product*> filter(const std::vector<Product*>& items,
                                 const Specification<Product>& spec) const override {
        std::vector<Product*> result;
        for (auto& item : items)
            if (spec.is_satisfied(item))
                result.push_back(item);
        return result;
    }
};
```

## Creating Specifications

Specifications define filtering criteria:

```cpp
struct ColorSpecification : Specification<Product> {
    Color color;
    ColorSpecification(Color color) : color(color) {}
    bool is_satisfied(Product* item) const override {
        return item->color == color;
    }
};

struct SizeSpecification : Specification<Product> {
    Size size;
    SizeSpecification(Size size) : size(size) {}
    bool is_satisfied(Product* item) const override {
        return item->size == size;
    }
};
```

## Combining Specifications

Create combinators for complex criteria:

```cpp

template <typename T>
struct AndSpecification : Specification<T> {
    const Specification<T>& first;
    const Specification<T>& second;

    AndSpecification(const Specification<T>& first, const Specification<T>& second)
        : first(first), second(second) {}

    bool is_satisfied(T* item) const override {
        return first.is_satisfied(item) && second.is_satisfied(item);
    }
};
```

## Usage

```cpp
ColorSpecification green(Color::green);
SizeSpecification large(Size::large);
AndSpecification<Product> green_and_large(green, large);

BetterFilter bf;
auto items = std::vector<Product*>{&apple, &tree, &house};
auto results = bf.filter(items, green_and_large);

for (auto& item : results)
    std::cout << item->name << " is green and large\n";
```

## Optional: Operator Overloading for Combinations

You can overload operators in the `Specification` base to make combining specs more concise:

```cpp
template <typename T>
struct Specification {
    virtual bool is_satisfied(T* item) const = 0;

    AndSpecification<T> operator&&(const Specification<T>& other) {
        return AndSpecification<T>(*this, other);
    }
};
```

Which allows usage like:

```cpp
auto spec = ColorSpecification(Color::green) && SizeSpecification(Size::large);
auto filtered = bf.filter(items, spec);
```

# Summary

- The Open-Closed Principle encourages designs that are open for extension but closed for modification.
-  Using the Specification Pattern, we can add new filtering criteria by extending classes without changing existing code.
- This improves scalability, maintainability, and aligns with enterprise design principles.
