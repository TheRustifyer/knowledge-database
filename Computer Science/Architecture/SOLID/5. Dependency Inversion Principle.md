The last SOLID principle is the Dependency Inversion Principle.

# Definition

The Dependency Inversion Principle (DIP) states:

> [!info]
> High-level modules should not depend on low-level modules; both should depend on abstractions.
> Abstractions should not depend on details; details should depend on abstractions.

What Are Abstractions?

Abstractions are typically interfaces or base classes.

When you depend on abstractions, your code becomes more flexible:
- You can swap out concrete implementations.
- You avoid hard-coding details and lower coupling.
# Example: Modeling Relationships

Suppose you are modeling relationships between people:

```cpp
enum class Relationship { parent, child, sibling };

struct Person {
    std::string name;
};
```

A naive concrete storage:

```cpp
struct Relationships {
    std::vector<std::tuple<Person, Relationship, Person>> relations;

    void add_parent_and_child(const Person& parent, const Person& child) {
        relations.push_back({parent, Relationship::parent, child});
        relations.push_back({child, Relationship::child, parent});
    }
};
```

# The Problem: Direct Dependency

Suppose you create a high-level module to analyze relationships:

```cpp
struct Research {
    Research(Relationships& relationships) {
        for (auto&& [first, rel, second] : relationships.relations) {
            if (first.name == "John" && rel == Relationship::parent)
                std::cout << "John has a child called " << second.name << "\n";
        }
    }
};
```

> [!warning]
> The high-level module `Research` is directly coupled to the low-level details of data storage (accessing `relations` directly).

If the storage structure changes, `Research` breaks.

# The Solution: Abstractions (Dependency Inversion)

Define an abstraction for querying relationships:

```cpp
struct RelationshipBrowser {
    virtual std::vector<Person> find_all_children_of(const std::string& name) const = 0;
};
```

Let your low-level module implement this interface:

```cpp
struct Relationships : RelationshipBrowser {
    std::vector<std::tuple<Person, Relationship, Person>> relations;
    void add_parent_and_child(const Person& parent, const Person& child) { /* ... */ }
    std::vector<Person> find_all_children_of(const std::string& name) const override {
        std::vector<Person> result;
        for (auto&& [first, rel, second] : relations) {
            if (first.name == name && rel == Relationship::parent)
                result.push_back(second);
        }
        return result;
    }
};
```

Now, your high-level module uses the abstraction:

```cpp
struct Research {
    Research(const RelationshipBrowser& browser) {
        for (auto& child : browser.find_all_children_of("John"))
            std::cout << "John has a child called " << child.name << "\n";
    }
};
```

The details of storage can change without breaking `Research`.

> [!info]
> DIP is not about dependency injection itself, but rather about depending on abstractions and making details depend on them, not the other way around.
# Summary & Benefits

- Flexibility: Swap implementations without changing high-level logic.
- Testability: Mock abstractions in tests.
- Robustness: Less breaking when low-level details change.
