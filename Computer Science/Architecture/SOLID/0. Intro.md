
>[!info] The SOLID principles are a set of software design principles introduced by Robert C. Martin, also known as Uncle Bob.

They represent only five specific principles selected from a much larger collection of design guidelines he has shared over the years.

Robert C. Martin has authored multiple books, articles, and blog posts on software design. While SOLID is just a subset of his work, it has become one of the most referenced frameworks in modern software engineering.

## Why We Study Them

The ==SOLID== principles frequently appear in modern design pattern literature.

Learning them will help you:
- Understand design decisions in professional and open-source projects.
- Write cleaner, more maintainable, and more extensible code.
- Follow best practices used by experienced developers.
- Recognize when these principles are applied or violated.

> [!important]
> Throughout this course, we will reference the SOLID principles while exploring various design patterns.

# Summary

Let’s summarize the key takeaways from this section on the SOLID design principles.

## Single Responsibility Principle (SRP)
A class should have only one reason to change. This aligns closely with the concept of separation of concerns, where different responsibilities are encapsulated in separate classes. This promotes independent refactoring and easier maintenance.

## Open-Closed Principle (OCP)
Classes should be open for extension but closed for modification. Modifying tested and shipped code to add features is discouraged. Instead, design your system using inheritance or composition to add functionality by extending behavior without altering existing code. The `Specification Pattern` is a great example of this approach.

## Liskov Substitution Principle (LSP)

Subtypes must be substitutable for their base types without breaking program correctness. Violating this principle leads to surprising and incorrect behavior, as seen in the classic Rectangle-Square example. Proper hierarchy design is essential to uphhold this principle.

## Interface Segregation Principle (ISP)

Interfaces should be small and focused. Avoid fat interfaces that force clients to implement methods they do not need. Instead, split large interfaces (or protocols) into multiple, specific ones. This prevents unnecessary stubs and exceptions, embracing the YAGNI (You Ain’t Gonna Need It) philosophy—don’t force clients to depend on features they won’t use.

## Dependency Inversion Principle (DIP)

High-level modules should not depend on low-level modules; both should depend on abstractions. Abstractions should not depend on details; details should depend on abstractions. 

This principle decouples the architectural layers and protects high-level logic from changes in low-level implementations. It is conceptually separate from dependency injection but often used in conjunction.

# Conclusion

These five principles together guide the design of clean, maintainable, extensible, and robust software. Understanding and applying SOLID principles empowers you to write code that adapts gracefully to change and scales well with complexity.

# SOLID Principles Cheat Sheet

| Principle                        | Core Idea                                                      | Key Benefit                         | Practical Tip                                      |
|---------------------------------|----------------------------------------------------------------|-----------------------------------|---------------------------------------------------|
| **Single Responsibility (SRP)** | A class should have one, and only one, reason to change.       | Easier maintenance & testing      | Separate concerns into distinct classes or modules. |
| **Open-Closed (OCP)**             | Open for extension, closed for modification.                   | Add features without breaking code | Use inheritance, interfaces, or composition to extend functionality. |
| **Liskov Substitution (LSP)**     | Subtypes must be substitutable for their base types.           | Reliable polymorphism             | Ensure subclasses honor base class contracts and behavior.                |
| **Interface Segregation (ISP)**   | Clients should not be forced to depend on unused methods.      | Avoid bloated interfaces          | Split large interfaces into focused, client-specific ones.                |
| **Dependency Inversion (DIP)**    | Depend on abstractions, not concrete implementations.          | Flexible and decoupled design     | Introduce interfaces/abstract classes; both high- and low-level modules depend on them. |

---

### Quick Guidelines

- **SRP:** When you notice a class doing multiple things, think about separating responsibilities.
- **OCP:** Avoid modifying tested code; add new code with new classes or components instead.
- **LSP:** Always check if derived classes truly behave like their base classes to avoid subtle bugs.
- **ISP:** Design small, role-specific interfaces instead of one large interface for all clients.
- **DIP:** High-level policy modules should rely on interfaces, not concrete classes; inversion of control facilitates this.

---

### Common Patterns to Help

- **Specification Pattern** (OCP): Encapsulates business rules and allows flexible filtering and validation.
- **Factory Pattern** (SRP/LSP): Abstracts instance creation to avoid misuse of inheritance and improve substitution.
- **Decorator Pattern** (ISP): Composes behaviors dynamically without changing interfaces.
- **Dependency Injection** (DIP): Supplies dependencies through constructors or setters to enable flexibility and testing.

---

Keep this cheat sheet handy as a reference to design cleaner, more maintainable software!
