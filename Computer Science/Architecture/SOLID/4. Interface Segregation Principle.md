The fourth SOLID principle is the Interface Segregation Principle (ISP).

# Definition

> [!info]
> The Interface Segregation Principle states:
Clients should not be forced to depend on methods they do not use.

In practical terms, keep your interfaces focused and avoid making them too large.

# The Problem with Large Interfaces

Suppose you have a `Document` type:

```cpp
struct Document { /* content */ };
```

You might be tempted to define a single interface for all document actions:

```cpp
struct IMachine {
    virtual void print(Document& doc) = 0;
    virtual void scan(Document& doc) = 0;
    virtual void fax(Document& doc) = 0;
};
```

A multifunction device, such as a printer-scanner-fax machine, can implement `IMachine` just fine.

```cpp
struct MultiFunctionPrinter : IMachine {
    /* Implements print, scan, fax */
};
```

> [!warning]
> Problems arise when you only want to implement part of the interface—such as creating a simple scanner.


You end up with meaningless methods, empty bodies, or throwing exceptions, which confuses clients and leads to poor design.

#  The Solution: Segregated Interfaces

Break the large interface into smaller, more focused ones:

```cpp
struct IPrinter {
    virtual void print(Document& doc) = 0;
};

struct IScanner {
    virtual void scan(Document& doc) = 0;
};

struct IFax {
    virtual void fax(Document& doc) = 0;
};
```

Now, when implementing a single-function device, you only implement the methods that matter:

```cpp
struct Printer : IPrinter {
    void print(Document& doc) override { /* print logic */ }
};

struct Scanner : IScanner {
    void scan(Document& doc) override { /* scan logic */ }
};
```

# Composing Multifunction Devices

If you build a machine that supports multiple functions, just use multiple interfaces—possibly with inheritance or composition:

```cpp
struct IMachine : IPrinter, IScanner { };

struct MultiFunctionMachine : IMachine {
    void print(Document& doc) override { /* print logic */ }
    void scan(Document& doc) override { /* scan logic */ }
};
```

Or use composition/decorator approaches:

```cpp
struct Machine : IMachine {
    IPrinter& printer;
    IScanner& scanner;
    Machine(IPrinter& p, IScanner& s) : printer(p), scanner(s) {}

    void print(Document& doc) override { printer.print(doc); }
    void scan(Document& doc) override { scanner.scan(doc); }
};
```

> [!info]
> The core of ISP is to avoid forcing classes to implement functionality they don’t need.

> [!tip] 
> The goal of ISP is to split interfaces to match real responsibilities.

# Summary

- Large, “fat” interfaces violate ISP and cause code duplication and wasted implementations.
- Segregating interfaces allows coherent, single-responsibility implementations.
- Composition and interface inheritance keep code modular and maintainable.
- Clients only depend on methods that are truly relevant.
